## Pokemon Type Ai

## 功能说明
根据已有的宝可梦的属性，分析目前的优势对抗属性和弱势对抗属性，并推荐下一只宝可梦的最佳属性，以及如果采纳该推荐，给出优势对抗属性和弱势对抗属性的情况，并继续推荐，直到满足六只。
属性评估会考虑攻击面和防御面

## 算法设计思路
对所有属性进行遍历。成本计算的方法：
* 攻击面：假如选择某属性，则其可以覆盖的“新的”克制属性的数量，如果这些属性对于目前已有的宝可梦是克制关系，则额外加分。
* 防御面：假如选择某属性，则其可以覆盖的“新的”抵御属性的数量，如果这些属性对于目前已有的宝可梦是克制关系，则额外加分。
由于答案只有一个位置，所以不需要随机优化（如果需要，可以参考mlrose：https://mlrose.readthedocs.io/en/stable/source/tutorial1.html）
求出最适合的属性，然后下一个，然后下一个。之后可以考虑对六个位置进行随机优化。

## 程序处理过程
1. 读取属性克制表，构建属性克制矩阵，之后使用index进行定位
2. 构建成本函数，根据既有属性、新属性、评分方式（综合、攻击重视、防御重视），给出该属性的评分。
3. 构建Ai程序，根据n个既有属性和评分方式，给出6-n个的推荐属性、推荐分，特点说明。
    * 特点说明包括对目前阵容的攻击面和防御面进行分析，会给出量化的指标。这个如果做出来，获取就可以取代原来的增加制判断，直接每次用新阵容检查对应指标即可得到最佳组合。
    * 阵容评估方法：
        * 防御面：对于每个属性，对每个已有属性，其被该属性攻击的显著性得分，如果全部显著，则分数为0，如果全部普通，分数为(1+1+1)/3，如果全部不显著，则为(2+2+2)/3
        * 攻击面：对于每个属性，对每个已有属性，攻击该属性的显著性得分，如果全部显著，则分数为(4+4+4)/3，如果全部普通，分数为(1+1+1)/3，如果全部不显著，则为(0.5+0.5+0.5)/3
        * 需要考虑的几点：
            * 如果是既有优势或劣势属性的重复，则要求产生额外减分和加分。这其实不是真相。实际上是，考虑到对抗属性较多，所以觉得如果优势属性重复，容易对其他属性考虑不周，如果劣势属性重复，容易对本属性考虑不周。
    * 报告的数据结构：
    
    ```
    {
        existsTypes:[],
        goodness:[],
        weakness:[],
        scoresMap:[],
        nextType:""
    }
    ```


## 经验

#### 组合评估的经验
* 对某一个属性，如果至少有一个属性对其攻击优势，至少一个属性对齐防御优势，则产生正面分数。而如果优势的数量增加，应该是对数变化，不会产生太多积极影响。
* 但如果一个队伍里面多个宝可梦对某个属性防御劣势或者攻击劣势，则会产生一定的负面影响。因为可能少量优势或者均势的宝可梦因为一些情况而无法发挥作用。
* 防御面的上限是全部无效，下限时全部显著；而攻击面的上限时全部显著，下限时全部无效。因为无效很少出现，所以就容易出现防御面实际上限低，攻击面实际下限高的情况。